// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               v6.33.1
// source: growtopia.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "gtools.growtopia";

export interface State {
  world: World | undefined;
  me: Me | undefined;
  status: number;
  inventory: Inventory | undefined;
}

export interface Inventory {
  items: Item[];
}

export interface CharacterState {
  buildRange: number;
  punchRange: number;
  flags: number;
  gravity: number;
  velocity: number;
}

export interface Me {
  netId: number;
  buildRange: number;
  punchRange: number;
  pos: Vec2F | undefined;
  state: number;
  character: CharacterState | undefined;
  serverPing: number;
  clientPing: number;
  timeSinceLogin: number;
  timeInWorld: number;
}

export interface Item {
  id: number;
  amount: number;
  flags: number;
}

export interface Vec2I {
  x: number;
  y: number;
}

export interface Vec4I {
  x: number;
  y: number;
  w: number;
  h: number;
}

export interface Vec2F {
  x: number;
  y: number;
}

export interface Player {
  /** avatar */
  spawn: Uint8Array;
  /** 1 */
  netID: number;
  /** 12839123 */
  userID: number;
  /** 12839123  awojdioajwidj=== | aowdjoiawjd=== */
  eid: Uint8Array;
  /** aoiwjdoj1i2j3o123= (b64decode length 32) */
  ip: Uint8Array;
  /** 0 0 20 20 */
  colrect:
    | Vec4I
    | undefined;
  /** 1820 810 */
  posXY: Vec2F | undefined;
  name: Uint8Array;
  /** {"PlayerWorldID":1,"WrenchCustomization":{"WrenchForegroundCanRotate":false,"WrenchForegroundID":-1,"WrenchIconID":-1}} */
  titleIcon: Uint8Array;
  /** absolute insanity */
  country: Uint8Array;
  /** 0 */
  invis: number;
  /** 0 */
  mstate: number;
  /** 0 */
  smstate: number;
  onlineID: Uint8Array;
  state: number;
}

export interface DroppedItem {
  id: number;
  x: number;
  y: number;
  amount: number;
  flags: number;
  uid: number;
}

export interface Dropped {
  nbItems: number;
  lastUid: number;
  items: DroppedItem[];
}

export interface Tile {
  fgId: number;
  bgId: number;
  parentBlockIndex: number;
  flags: number;
  extra: Uint8Array;
  x: number;
  y: number;
  lockBlockIndex: number;
  jsonData: Uint8Array;
}

/** the world data */
export interface WorldInner {
  name: Uint8Array;
  width: number;
  height: number;
  nbTiles: number;
  tiles: Tile[];
  dropped: Dropped | undefined;
  garbageStart: number;
}

/** the world state (not included in data) */
export interface World {
  inner: WorldInner | undefined;
  player: Player[];
}

function createBaseState(): State {
  return { world: undefined, me: undefined, status: 0, inventory: undefined };
}

export const State: MessageFns<State> = {
  encode(message: State, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(10).fork()).join();
    }
    if (message.me !== undefined) {
      Me.encode(message.me, writer.uint32(26).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(32).uint32(message.status);
    }
    if (message.inventory !== undefined) {
      Inventory.encode(message.inventory, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): State {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.me = Me.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.inventory = Inventory.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): State {
    return {
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      me: isSet(object.me) ? Me.fromJSON(object.me) : undefined,
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      inventory: isSet(object.inventory) ? Inventory.fromJSON(object.inventory) : undefined,
    };
  },

  toJSON(message: State): unknown {
    const obj: any = {};
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.me !== undefined) {
      obj.me = Me.toJSON(message.me);
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.inventory !== undefined) {
      obj.inventory = Inventory.toJSON(message.inventory);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<State>, I>>(base?: I): State {
    return State.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<State>, I>>(object: I): State {
    const message = createBaseState();
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.me = (object.me !== undefined && object.me !== null) ? Me.fromPartial(object.me) : undefined;
    message.status = object.status ?? 0;
    message.inventory = (object.inventory !== undefined && object.inventory !== null)
      ? Inventory.fromPartial(object.inventory)
      : undefined;
    return message;
  },
};

function createBaseInventory(): Inventory {
  return { items: [] };
}

export const Inventory: MessageFns<Inventory> = {
  encode(message: Inventory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      Item.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Inventory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInventory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(Item.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Inventory {
    return { items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => Item.fromJSON(e)) : [] };
  },

  toJSON(message: Inventory): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => Item.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Inventory>, I>>(base?: I): Inventory {
    return Inventory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Inventory>, I>>(object: I): Inventory {
    const message = createBaseInventory();
    message.items = object.items?.map((e) => Item.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCharacterState(): CharacterState {
  return { buildRange: 0, punchRange: 0, flags: 0, gravity: 0, velocity: 0 };
}

export const CharacterState: MessageFns<CharacterState> = {
  encode(message: CharacterState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.buildRange !== 0) {
      writer.uint32(8).uint32(message.buildRange);
    }
    if (message.punchRange !== 0) {
      writer.uint32(16).uint32(message.punchRange);
    }
    if (message.flags !== 0) {
      writer.uint32(24).uint32(message.flags);
    }
    if (message.gravity !== 0) {
      writer.uint32(37).float(message.gravity);
    }
    if (message.velocity !== 0) {
      writer.uint32(45).float(message.velocity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.buildRange = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.punchRange = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.flags = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.gravity = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.velocity = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterState {
    return {
      buildRange: isSet(object.buildRange)
        ? globalThis.Number(object.buildRange)
        : isSet(object.build_range)
        ? globalThis.Number(object.build_range)
        : 0,
      punchRange: isSet(object.punchRange)
        ? globalThis.Number(object.punchRange)
        : isSet(object.punch_range)
        ? globalThis.Number(object.punch_range)
        : 0,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
      gravity: isSet(object.gravity) ? globalThis.Number(object.gravity) : 0,
      velocity: isSet(object.velocity) ? globalThis.Number(object.velocity) : 0,
    };
  },

  toJSON(message: CharacterState): unknown {
    const obj: any = {};
    if (message.buildRange !== 0) {
      obj.buildRange = Math.round(message.buildRange);
    }
    if (message.punchRange !== 0) {
      obj.punchRange = Math.round(message.punchRange);
    }
    if (message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    if (message.gravity !== 0) {
      obj.gravity = message.gravity;
    }
    if (message.velocity !== 0) {
      obj.velocity = message.velocity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterState>, I>>(base?: I): CharacterState {
    return CharacterState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterState>, I>>(object: I): CharacterState {
    const message = createBaseCharacterState();
    message.buildRange = object.buildRange ?? 0;
    message.punchRange = object.punchRange ?? 0;
    message.flags = object.flags ?? 0;
    message.gravity = object.gravity ?? 0;
    message.velocity = object.velocity ?? 0;
    return message;
  },
};

function createBaseMe(): Me {
  return {
    netId: 0,
    buildRange: 0,
    punchRange: 0,
    pos: undefined,
    state: 0,
    character: undefined,
    serverPing: 0,
    clientPing: 0,
    timeSinceLogin: 0,
    timeInWorld: 0,
  };
}

export const Me: MessageFns<Me> = {
  encode(message: Me, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.netId !== 0) {
      writer.uint32(24).int32(message.netId);
    }
    if (message.buildRange !== 0) {
      writer.uint32(8).uint32(message.buildRange);
    }
    if (message.punchRange !== 0) {
      writer.uint32(16).uint32(message.punchRange);
    }
    if (message.pos !== undefined) {
      Vec2F.encode(message.pos, writer.uint32(34).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(72).uint32(message.state);
    }
    if (message.character !== undefined) {
      CharacterState.encode(message.character, writer.uint32(82).fork()).join();
    }
    if (message.serverPing !== 0) {
      writer.uint32(40).uint32(message.serverPing);
    }
    if (message.clientPing !== 0) {
      writer.uint32(64).uint32(message.clientPing);
    }
    if (message.timeSinceLogin !== 0) {
      writer.uint32(53).float(message.timeSinceLogin);
    }
    if (message.timeInWorld !== 0) {
      writer.uint32(61).float(message.timeInWorld);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Me {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.netId = reader.int32();
          continue;
        }
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.buildRange = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.punchRange = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pos = Vec2F.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.state = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.character = CharacterState.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.serverPing = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.clientPing = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.timeSinceLogin = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.timeInWorld = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Me {
    return {
      netId: isSet(object.netId)
        ? globalThis.Number(object.netId)
        : isSet(object.net_id)
        ? globalThis.Number(object.net_id)
        : 0,
      buildRange: isSet(object.buildRange)
        ? globalThis.Number(object.buildRange)
        : isSet(object.build_range)
        ? globalThis.Number(object.build_range)
        : 0,
      punchRange: isSet(object.punchRange)
        ? globalThis.Number(object.punchRange)
        : isSet(object.punch_range)
        ? globalThis.Number(object.punch_range)
        : 0,
      pos: isSet(object.pos) ? Vec2F.fromJSON(object.pos) : undefined,
      state: isSet(object.state) ? globalThis.Number(object.state) : 0,
      character: isSet(object.character) ? CharacterState.fromJSON(object.character) : undefined,
      serverPing: isSet(object.serverPing)
        ? globalThis.Number(object.serverPing)
        : isSet(object.server_ping)
        ? globalThis.Number(object.server_ping)
        : 0,
      clientPing: isSet(object.clientPing)
        ? globalThis.Number(object.clientPing)
        : isSet(object.client_ping)
        ? globalThis.Number(object.client_ping)
        : 0,
      timeSinceLogin: isSet(object.timeSinceLogin)
        ? globalThis.Number(object.timeSinceLogin)
        : isSet(object.time_since_login)
        ? globalThis.Number(object.time_since_login)
        : 0,
      timeInWorld: isSet(object.timeInWorld)
        ? globalThis.Number(object.timeInWorld)
        : isSet(object.time_in_world)
        ? globalThis.Number(object.time_in_world)
        : 0,
    };
  },

  toJSON(message: Me): unknown {
    const obj: any = {};
    if (message.netId !== 0) {
      obj.netId = Math.round(message.netId);
    }
    if (message.buildRange !== 0) {
      obj.buildRange = Math.round(message.buildRange);
    }
    if (message.punchRange !== 0) {
      obj.punchRange = Math.round(message.punchRange);
    }
    if (message.pos !== undefined) {
      obj.pos = Vec2F.toJSON(message.pos);
    }
    if (message.state !== 0) {
      obj.state = Math.round(message.state);
    }
    if (message.character !== undefined) {
      obj.character = CharacterState.toJSON(message.character);
    }
    if (message.serverPing !== 0) {
      obj.serverPing = Math.round(message.serverPing);
    }
    if (message.clientPing !== 0) {
      obj.clientPing = Math.round(message.clientPing);
    }
    if (message.timeSinceLogin !== 0) {
      obj.timeSinceLogin = message.timeSinceLogin;
    }
    if (message.timeInWorld !== 0) {
      obj.timeInWorld = message.timeInWorld;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Me>, I>>(base?: I): Me {
    return Me.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Me>, I>>(object: I): Me {
    const message = createBaseMe();
    message.netId = object.netId ?? 0;
    message.buildRange = object.buildRange ?? 0;
    message.punchRange = object.punchRange ?? 0;
    message.pos = (object.pos !== undefined && object.pos !== null) ? Vec2F.fromPartial(object.pos) : undefined;
    message.state = object.state ?? 0;
    message.character = (object.character !== undefined && object.character !== null)
      ? CharacterState.fromPartial(object.character)
      : undefined;
    message.serverPing = object.serverPing ?? 0;
    message.clientPing = object.clientPing ?? 0;
    message.timeSinceLogin = object.timeSinceLogin ?? 0;
    message.timeInWorld = object.timeInWorld ?? 0;
    return message;
  },
};

function createBaseItem(): Item {
  return { id: 0, amount: 0, flags: 0 };
}

export const Item: MessageFns<Item> = {
  encode(message: Item, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.amount !== 0) {
      writer.uint32(16).uint32(message.amount);
    }
    if (message.flags !== 0) {
      writer.uint32(24).uint32(message.flags);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Item {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.flags = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Item {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
    };
  },

  toJSON(message: Item): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Item>, I>>(base?: I): Item {
    return Item.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Item>, I>>(object: I): Item {
    const message = createBaseItem();
    message.id = object.id ?? 0;
    message.amount = object.amount ?? 0;
    message.flags = object.flags ?? 0;
    return message;
  },
};

function createBaseVec2I(): Vec2I {
  return { x: 0, y: 0 };
}

export const Vec2I: MessageFns<Vec2I> = {
  encode(message: Vec2I, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(8).uint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).uint32(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vec2I {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVec2I();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.x = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.y = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vec2I {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: Vec2I): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Vec2I>, I>>(base?: I): Vec2I {
    return Vec2I.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Vec2I>, I>>(object: I): Vec2I {
    const message = createBaseVec2I();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseVec4I(): Vec4I {
  return { x: 0, y: 0, w: 0, h: 0 };
}

export const Vec4I: MessageFns<Vec4I> = {
  encode(message: Vec4I, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(8).uint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).uint32(message.y);
    }
    if (message.w !== 0) {
      writer.uint32(24).uint32(message.w);
    }
    if (message.h !== 0) {
      writer.uint32(32).uint32(message.h);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vec4I {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVec4I();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.x = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.y = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.w = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.h = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vec4I {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      w: isSet(object.w) ? globalThis.Number(object.w) : 0,
      h: isSet(object.h) ? globalThis.Number(object.h) : 0,
    };
  },

  toJSON(message: Vec4I): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    if (message.w !== 0) {
      obj.w = Math.round(message.w);
    }
    if (message.h !== 0) {
      obj.h = Math.round(message.h);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Vec4I>, I>>(base?: I): Vec4I {
    return Vec4I.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Vec4I>, I>>(object: I): Vec4I {
    const message = createBaseVec4I();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.w = object.w ?? 0;
    message.h = object.h ?? 0;
    return message;
  },
};

function createBaseVec2F(): Vec2F {
  return { x: 0, y: 0 };
}

export const Vec2F: MessageFns<Vec2F> = {
  encode(message: Vec2F, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vec2F {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVec2F();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vec2F {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: Vec2F): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Vec2F>, I>>(base?: I): Vec2F {
    return Vec2F.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Vec2F>, I>>(object: I): Vec2F {
    const message = createBaseVec2F();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBasePlayer(): Player {
  return {
    spawn: new Uint8Array(0),
    netID: 0,
    userID: 0,
    eid: new Uint8Array(0),
    ip: new Uint8Array(0),
    colrect: undefined,
    posXY: undefined,
    name: new Uint8Array(0),
    titleIcon: new Uint8Array(0),
    country: new Uint8Array(0),
    invis: 0,
    mstate: 0,
    smstate: 0,
    onlineID: new Uint8Array(0),
    state: 0,
  };
}

export const Player: MessageFns<Player> = {
  encode(message: Player, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.spawn.length !== 0) {
      writer.uint32(10).bytes(message.spawn);
    }
    if (message.netID !== 0) {
      writer.uint32(16).uint32(message.netID);
    }
    if (message.userID !== 0) {
      writer.uint32(24).uint32(message.userID);
    }
    if (message.eid.length !== 0) {
      writer.uint32(34).bytes(message.eid);
    }
    if (message.ip.length !== 0) {
      writer.uint32(42).bytes(message.ip);
    }
    if (message.colrect !== undefined) {
      Vec4I.encode(message.colrect, writer.uint32(50).fork()).join();
    }
    if (message.posXY !== undefined) {
      Vec2F.encode(message.posXY, writer.uint32(58).fork()).join();
    }
    if (message.name.length !== 0) {
      writer.uint32(66).bytes(message.name);
    }
    if (message.titleIcon.length !== 0) {
      writer.uint32(74).bytes(message.titleIcon);
    }
    if (message.country.length !== 0) {
      writer.uint32(82).bytes(message.country);
    }
    if (message.invis !== 0) {
      writer.uint32(88).uint32(message.invis);
    }
    if (message.mstate !== 0) {
      writer.uint32(96).uint32(message.mstate);
    }
    if (message.smstate !== 0) {
      writer.uint32(104).uint32(message.smstate);
    }
    if (message.onlineID.length !== 0) {
      writer.uint32(114).bytes(message.onlineID);
    }
    if (message.state !== 0) {
      writer.uint32(120).uint32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Player {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.spawn = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.netID = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.userID = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.eid = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ip = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.colrect = Vec4I.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.posXY = Vec2F.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.name = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.titleIcon = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.country = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.invis = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.mstate = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.smstate = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.onlineID = reader.bytes();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.state = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Player {
    return {
      spawn: isSet(object.spawn) ? bytesFromBase64(object.spawn) : new Uint8Array(0),
      netID: isSet(object.netID) ? globalThis.Number(object.netID) : 0,
      userID: isSet(object.userID) ? globalThis.Number(object.userID) : 0,
      eid: isSet(object.eid) ? bytesFromBase64(object.eid) : new Uint8Array(0),
      ip: isSet(object.ip) ? bytesFromBase64(object.ip) : new Uint8Array(0),
      colrect: isSet(object.colrect) ? Vec4I.fromJSON(object.colrect) : undefined,
      posXY: isSet(object.posXY) ? Vec2F.fromJSON(object.posXY) : undefined,
      name: isSet(object.name) ? bytesFromBase64(object.name) : new Uint8Array(0),
      titleIcon: isSet(object.titleIcon) ? bytesFromBase64(object.titleIcon) : new Uint8Array(0),
      country: isSet(object.country) ? bytesFromBase64(object.country) : new Uint8Array(0),
      invis: isSet(object.invis) ? globalThis.Number(object.invis) : 0,
      mstate: isSet(object.mstate) ? globalThis.Number(object.mstate) : 0,
      smstate: isSet(object.smstate) ? globalThis.Number(object.smstate) : 0,
      onlineID: isSet(object.onlineID) ? bytesFromBase64(object.onlineID) : new Uint8Array(0),
      state: isSet(object.state) ? globalThis.Number(object.state) : 0,
    };
  },

  toJSON(message: Player): unknown {
    const obj: any = {};
    if (message.spawn.length !== 0) {
      obj.spawn = base64FromBytes(message.spawn);
    }
    if (message.netID !== 0) {
      obj.netID = Math.round(message.netID);
    }
    if (message.userID !== 0) {
      obj.userID = Math.round(message.userID);
    }
    if (message.eid.length !== 0) {
      obj.eid = base64FromBytes(message.eid);
    }
    if (message.ip.length !== 0) {
      obj.ip = base64FromBytes(message.ip);
    }
    if (message.colrect !== undefined) {
      obj.colrect = Vec4I.toJSON(message.colrect);
    }
    if (message.posXY !== undefined) {
      obj.posXY = Vec2F.toJSON(message.posXY);
    }
    if (message.name.length !== 0) {
      obj.name = base64FromBytes(message.name);
    }
    if (message.titleIcon.length !== 0) {
      obj.titleIcon = base64FromBytes(message.titleIcon);
    }
    if (message.country.length !== 0) {
      obj.country = base64FromBytes(message.country);
    }
    if (message.invis !== 0) {
      obj.invis = Math.round(message.invis);
    }
    if (message.mstate !== 0) {
      obj.mstate = Math.round(message.mstate);
    }
    if (message.smstate !== 0) {
      obj.smstate = Math.round(message.smstate);
    }
    if (message.onlineID.length !== 0) {
      obj.onlineID = base64FromBytes(message.onlineID);
    }
    if (message.state !== 0) {
      obj.state = Math.round(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Player>, I>>(base?: I): Player {
    return Player.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Player>, I>>(object: I): Player {
    const message = createBasePlayer();
    message.spawn = object.spawn ?? new Uint8Array(0);
    message.netID = object.netID ?? 0;
    message.userID = object.userID ?? 0;
    message.eid = object.eid ?? new Uint8Array(0);
    message.ip = object.ip ?? new Uint8Array(0);
    message.colrect = (object.colrect !== undefined && object.colrect !== null)
      ? Vec4I.fromPartial(object.colrect)
      : undefined;
    message.posXY = (object.posXY !== undefined && object.posXY !== null) ? Vec2F.fromPartial(object.posXY) : undefined;
    message.name = object.name ?? new Uint8Array(0);
    message.titleIcon = object.titleIcon ?? new Uint8Array(0);
    message.country = object.country ?? new Uint8Array(0);
    message.invis = object.invis ?? 0;
    message.mstate = object.mstate ?? 0;
    message.smstate = object.smstate ?? 0;
    message.onlineID = object.onlineID ?? new Uint8Array(0);
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseDroppedItem(): DroppedItem {
  return { id: 0, x: 0, y: 0, amount: 0, flags: 0, uid: 0 };
}

export const DroppedItem: MessageFns<DroppedItem> = {
  encode(message: DroppedItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.x !== 0) {
      writer.uint32(21).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(29).float(message.y);
    }
    if (message.amount !== 0) {
      writer.uint32(32).uint32(message.amount);
    }
    if (message.flags !== 0) {
      writer.uint32(40).uint32(message.flags);
    }
    if (message.uid !== 0) {
      writer.uint32(48).uint32(message.uid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DroppedItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDroppedItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.x = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.y = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.amount = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.flags = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.uid = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DroppedItem {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
      uid: isSet(object.uid) ? globalThis.Number(object.uid) : 0,
    };
  },

  toJSON(message: DroppedItem): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    if (message.uid !== 0) {
      obj.uid = Math.round(message.uid);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DroppedItem>, I>>(base?: I): DroppedItem {
    return DroppedItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DroppedItem>, I>>(object: I): DroppedItem {
    const message = createBaseDroppedItem();
    message.id = object.id ?? 0;
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.amount = object.amount ?? 0;
    message.flags = object.flags ?? 0;
    message.uid = object.uid ?? 0;
    return message;
  },
};

function createBaseDropped(): Dropped {
  return { nbItems: 0, lastUid: 0, items: [] };
}

export const Dropped: MessageFns<Dropped> = {
  encode(message: Dropped, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nbItems !== 0) {
      writer.uint32(8).uint32(message.nbItems);
    }
    if (message.lastUid !== 0) {
      writer.uint32(16).uint32(message.lastUid);
    }
    for (const v of message.items) {
      DroppedItem.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dropped {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDropped();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nbItems = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lastUid = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.items.push(DroppedItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dropped {
    return {
      nbItems: isSet(object.nbItems)
        ? globalThis.Number(object.nbItems)
        : isSet(object.nb_items)
        ? globalThis.Number(object.nb_items)
        : 0,
      lastUid: isSet(object.lastUid)
        ? globalThis.Number(object.lastUid)
        : isSet(object.last_uid)
        ? globalThis.Number(object.last_uid)
        : 0,
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => DroppedItem.fromJSON(e)) : [],
    };
  },

  toJSON(message: Dropped): unknown {
    const obj: any = {};
    if (message.nbItems !== 0) {
      obj.nbItems = Math.round(message.nbItems);
    }
    if (message.lastUid !== 0) {
      obj.lastUid = Math.round(message.lastUid);
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => DroppedItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Dropped>, I>>(base?: I): Dropped {
    return Dropped.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Dropped>, I>>(object: I): Dropped {
    const message = createBaseDropped();
    message.nbItems = object.nbItems ?? 0;
    message.lastUid = object.lastUid ?? 0;
    message.items = object.items?.map((e) => DroppedItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTile(): Tile {
  return {
    fgId: 0,
    bgId: 0,
    parentBlockIndex: 0,
    flags: 0,
    extra: new Uint8Array(0),
    x: 0,
    y: 0,
    lockBlockIndex: 0,
    jsonData: new Uint8Array(0),
  };
}

export const Tile: MessageFns<Tile> = {
  encode(message: Tile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fgId !== 0) {
      writer.uint32(8).uint32(message.fgId);
    }
    if (message.bgId !== 0) {
      writer.uint32(16).uint32(message.bgId);
    }
    if (message.parentBlockIndex !== 0) {
      writer.uint32(24).uint32(message.parentBlockIndex);
    }
    if (message.flags !== 0) {
      writer.uint32(32).uint32(message.flags);
    }
    if (message.extra.length !== 0) {
      writer.uint32(42).bytes(message.extra);
    }
    if (message.x !== 0) {
      writer.uint32(48).uint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(56).uint32(message.y);
    }
    if (message.lockBlockIndex !== 0) {
      writer.uint32(64).uint32(message.lockBlockIndex);
    }
    if (message.jsonData.length !== 0) {
      writer.uint32(74).bytes(message.jsonData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fgId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.bgId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.parentBlockIndex = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.flags = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.extra = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.x = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.y = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.lockBlockIndex = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.jsonData = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tile {
    return {
      fgId: isSet(object.fgId)
        ? globalThis.Number(object.fgId)
        : isSet(object.fg_id)
        ? globalThis.Number(object.fg_id)
        : 0,
      bgId: isSet(object.bgId)
        ? globalThis.Number(object.bgId)
        : isSet(object.bg_id)
        ? globalThis.Number(object.bg_id)
        : 0,
      parentBlockIndex: isSet(object.parentBlockIndex)
        ? globalThis.Number(object.parentBlockIndex)
        : isSet(object.parent_block_index)
        ? globalThis.Number(object.parent_block_index)
        : 0,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
      extra: isSet(object.extra) ? bytesFromBase64(object.extra) : new Uint8Array(0),
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      lockBlockIndex: isSet(object.lockBlockIndex)
        ? globalThis.Number(object.lockBlockIndex)
        : isSet(object.lock_block_index)
        ? globalThis.Number(object.lock_block_index)
        : 0,
      jsonData: isSet(object.jsonData)
        ? bytesFromBase64(object.jsonData)
        : isSet(object.json_data)
        ? bytesFromBase64(object.json_data)
        : new Uint8Array(0),
    };
  },

  toJSON(message: Tile): unknown {
    const obj: any = {};
    if (message.fgId !== 0) {
      obj.fgId = Math.round(message.fgId);
    }
    if (message.bgId !== 0) {
      obj.bgId = Math.round(message.bgId);
    }
    if (message.parentBlockIndex !== 0) {
      obj.parentBlockIndex = Math.round(message.parentBlockIndex);
    }
    if (message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    if (message.extra.length !== 0) {
      obj.extra = base64FromBytes(message.extra);
    }
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    if (message.lockBlockIndex !== 0) {
      obj.lockBlockIndex = Math.round(message.lockBlockIndex);
    }
    if (message.jsonData.length !== 0) {
      obj.jsonData = base64FromBytes(message.jsonData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tile>, I>>(base?: I): Tile {
    return Tile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tile>, I>>(object: I): Tile {
    const message = createBaseTile();
    message.fgId = object.fgId ?? 0;
    message.bgId = object.bgId ?? 0;
    message.parentBlockIndex = object.parentBlockIndex ?? 0;
    message.flags = object.flags ?? 0;
    message.extra = object.extra ?? new Uint8Array(0);
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.lockBlockIndex = object.lockBlockIndex ?? 0;
    message.jsonData = object.jsonData ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWorldInner(): WorldInner {
  return { name: new Uint8Array(0), width: 0, height: 0, nbTiles: 0, tiles: [], dropped: undefined, garbageStart: 0 };
}

export const WorldInner: MessageFns<WorldInner> = {
  encode(message: WorldInner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name.length !== 0) {
      writer.uint32(10).bytes(message.name);
    }
    if (message.width !== 0) {
      writer.uint32(40).uint32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(48).uint32(message.height);
    }
    if (message.nbTiles !== 0) {
      writer.uint32(56).uint32(message.nbTiles);
    }
    for (const v of message.tiles) {
      Tile.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.dropped !== undefined) {
      Dropped.encode(message.dropped, writer.uint32(34).fork()).join();
    }
    if (message.garbageStart !== 0) {
      writer.uint32(64).int32(message.garbageStart);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorldInner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorldInner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.width = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.height = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.nbTiles = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tiles.push(Tile.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dropped = Dropped.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.garbageStart = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorldInner {
    return {
      name: isSet(object.name) ? bytesFromBase64(object.name) : new Uint8Array(0),
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      nbTiles: isSet(object.nbTiles)
        ? globalThis.Number(object.nbTiles)
        : isSet(object.nb_tiles)
        ? globalThis.Number(object.nb_tiles)
        : 0,
      tiles: globalThis.Array.isArray(object?.tiles) ? object.tiles.map((e: any) => Tile.fromJSON(e)) : [],
      dropped: isSet(object.dropped) ? Dropped.fromJSON(object.dropped) : undefined,
      garbageStart: isSet(object.garbageStart)
        ? globalThis.Number(object.garbageStart)
        : isSet(object.garbage_start)
        ? globalThis.Number(object.garbage_start)
        : 0,
    };
  },

  toJSON(message: WorldInner): unknown {
    const obj: any = {};
    if (message.name.length !== 0) {
      obj.name = base64FromBytes(message.name);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.nbTiles !== 0) {
      obj.nbTiles = Math.round(message.nbTiles);
    }
    if (message.tiles?.length) {
      obj.tiles = message.tiles.map((e) => Tile.toJSON(e));
    }
    if (message.dropped !== undefined) {
      obj.dropped = Dropped.toJSON(message.dropped);
    }
    if (message.garbageStart !== 0) {
      obj.garbageStart = Math.round(message.garbageStart);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorldInner>, I>>(base?: I): WorldInner {
    return WorldInner.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorldInner>, I>>(object: I): WorldInner {
    const message = createBaseWorldInner();
    message.name = object.name ?? new Uint8Array(0);
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.nbTiles = object.nbTiles ?? 0;
    message.tiles = object.tiles?.map((e) => Tile.fromPartial(e)) || [];
    message.dropped = (object.dropped !== undefined && object.dropped !== null)
      ? Dropped.fromPartial(object.dropped)
      : undefined;
    message.garbageStart = object.garbageStart ?? 0;
    return message;
  },
};

function createBaseWorld(): World {
  return { inner: undefined, player: [] };
}

export const World: MessageFns<World> = {
  encode(message: World, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inner !== undefined) {
      WorldInner.encode(message.inner, writer.uint32(10).fork()).join();
    }
    for (const v of message.player) {
      Player.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): World {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorld();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inner = WorldInner.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.player.push(Player.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): World {
    return {
      inner: isSet(object.inner) ? WorldInner.fromJSON(object.inner) : undefined,
      player: globalThis.Array.isArray(object?.player) ? object.player.map((e: any) => Player.fromJSON(e)) : [],
    };
  },

  toJSON(message: World): unknown {
    const obj: any = {};
    if (message.inner !== undefined) {
      obj.inner = WorldInner.toJSON(message.inner);
    }
    if (message.player?.length) {
      obj.player = message.player.map((e) => Player.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<World>, I>>(base?: I): World {
    return World.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<World>, I>>(object: I): World {
    const message = createBaseWorld();
    message.inner = (object.inner !== undefined && object.inner !== null)
      ? WorldInner.fromPartial(object.inner)
      : undefined;
    message.player = object.player?.map((e) => Player.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
